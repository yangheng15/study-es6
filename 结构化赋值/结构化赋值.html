<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
       

        // 可计算属性 
        // let front = 'elem-';
        // let name = 'zhansan';
        // let stuff = 'stuff';
        // let stuffList = {
        //     ['ele' + stuff] : name
        // }
        // console.log(stuffList['ele' + stuff]);

        //es6中福安与对象新增的方法
        // 定义新的方法不在全局定义,也不再Object.prototype
        //静态方法Object.is() 加强比较运算 == ===
        // console.log(Object.is(+0,-0));//false 有区别但是但是===不能区别出来
        // console.log(+0 === -0)//ture
        // console.log([] == 0); //+[] 转换成数组 true 
        // console.log([] == false) // ture  转换为0 == false 

        // Object.assign()//把friend对象上面的属性 copy到person对象上面
        // function mixin(receive,obj) {
        //     for(let prop in obj) {
        //         receive[prop] = obj[prop];

        //     }
        //     return receive;
        // }

        // let person = {
        //     name : ['wxb','yangheng'],
        //     age : 18,
        //     height : 180,
        //     height : 170 //es5之前会报错现在不会报错直接覆盖前面的

        // }
        // let friend = {
        //     name : ['wxb'],
        //     weight : 100,
        //     height :100
        // }
        // let obj = {
        //     sex : '男'
        // }
        // // mixin(person,friend);
        // let p = Object.assign(person,friend,obj);//会返回一个数组不是深度拷贝将friend,obj 上面的属性都拷贝到person中
        // console.log(person);

            // Object.keys(obj) //返回对象的属性key以数组形式返回[key1,key2]
            // Object.values() //返回一个数组[value1,value2]的形式返回
            // Object.entries()//返回[key:value,key2:value2];

        //新增原型方法
        // let p = {
        //     sayName() {
        //         console.log(this.name);
        //     }
        // }
        // let person = Object.create(p);
        // //获取原型
        // // person.__proto__ 可以获取原型但是不好暴露原型
        // Object.getPrototypeOf(person)//这个方式更好也可以获取原型

        function Person(name = 'none') {
            this.name = name;
        }

        Person.prototype.sayName = function () {
            console.log(this.name);
        }
        var p1 = new Person();
        // p1.sayName();

        Person.prototype.sayName = function () {
            console.log(this.name + 'proto');
        }
        var p2 = new Person();
        // p2.sayName();

        let obj = {
            sayName () {
                console.log(this.name + 'obj');
            }
        }
        // Object.getPrototypeOf(xx);
        Object.setPrototypeOf(p1,obj);//指定某个对象的原型 

        // p1.sayName();

        let p3 = {
            name : 'p3',
            sagName() {
                // console.log(super);  
                // Object.getPrototypeOf(this).sayName.call(this);
                super.sayName.call(this);//super 指向当前对象的原型
            }
            // sagName : function {//函数简写的方式可以使用super因为可以直接绑定到[homeObject]上面而这个方式不可以

            //     // console.log(super);  
            //     // Object.getPrototypeOf(this).sayName.call(this);
            //     super.sayName.call(this);//super 指向当前对象的原型
            // }
        }
        Object.setPrototypeOf(p3,p1);
        p3.sagName();


        //解构赋值 
        data = {
            director : 'xxx',
            imgs : [],
            casts : {}
        }
        // let director = data.director;
        // let imgs = data.imgs;
        // let casts = data.casts;
        // ...很多条属性可以通过解构赋值解决
        //解构赋值
        // let director,imgs,casts;
        // ({director,imgs,casts} = data);
        let {director,casts,imgs} = data;//值必须和属性名相同调换位置也可以
        console.log(director,imgs,casts);
        // let {director : Dir,imgs : im,casts : cs} = {director : 'xxx',imgs : [],casts : {}};//会存在Dir im cs中
        // 默认赋值
        // let {director:Dir,imgs,casts='123'} = data;
        // console.log(Dir,imgs,casts);
            
        //数组结构赋值
        let arr = [1,3,4];
        let {0:a,1:b,2:c} = arr;
        console.log(a,b,c);

        let {length} = arr;
        console.log(length);

        let arr1 = [1,2,3,{name:'yang'}];
        let [,,,{name}] = arr1;
        console.log(name);

        let arr2 = [1,2,3];
        let [x,y,z] = arr;
        console.log(x,y,z);
    </script>
    
</body>
</html> 