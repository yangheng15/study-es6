<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <!-- 
        箭头函数
     -->
    <script>


        //正常
        // let show = (name,age) => {
        //     console.log(name,age);
        // }

        // let fn = (a,b) => a+b//相当于 let fn = (a,b) => {return a + b}
        // console.log(fn(1,3));
        //在箭头函数中返回对象
        // let returnObj = (name) => ({name:name});//强制变成表达式才可以，否则js认为是代码块
        // let sum = x => y => z => x + y + z;
        // console.log(sum(1)(2)(3));
        // 相当于 当参数==1可以去掉括号
        // let sum = (x) => {
        //     return (y) => {
        //         return (z) => {
        //             return x + y + z;
        //         }
        //     }
        // }
        // let test = () => {

        // }
            // es5环境下块级作用域里面的函数回无视跨级作用于跑到外面
        // function f() { console.log('I am outside!'); }
        // (function () {
        // if (false) {
        //     function f() { console.log('I am inside!'); }      
        // }
        // f();
        // }());
    
            // es6环境下如果不适用let表达式声明，将类似于var声明，预编译阶段，var f = undefined
        // function f() { console.log('I am outside!'); }

        // (function () {
        // if (false) {
        //     // 重复声明一次函数f
        //     // function f() { console.log('I am inside!'); }
        //     let f = function () {
        //         console.log('I am inside!');
        //     }
        // }
        // f();
        // }());

        // 箭头函数的arguments
        // let sum = (a,b) => {
        //     console.log(arguments,a,b);//arguments没有定义
        // }
        // sum(1,2);

            // function outside(a,b) {
            //     let sum = (a,b) => {
            //      console.log(arguments,a,b);//arguments是最外层非箭头函数的argements
            //   }
            //   sum(1,2);
            // }
            // outside(3,4,5);

            // 箭头函数的this 如果没有最外层的非箭头函数，this为window，如果有由那个非箭头函数的this决定
            // let sum = () => {
            //     console.log(this);//window
            // }
            // sum();
            a = 123;
            let sum = () => console.log(this.a);//this -> window
            let obj1 = {
                a : 123,
                fun : sum
            }
            obj1.fun();
            
            let obj = {
                a : 'yang',
                fn() {
                    return () => {
                        console.log(this);
                    }
                }
            }
            obj.fn()();//this -> obj

            // let obj = {
            //     a : 'yang',
            //     fn() {
            //         return function () {
            //             console.log(this);
            //         }
            //     }
            // }
            // obj.fn()();//this ->window


        //立即执行函数
        // let fn = (name => name)('wxb');

        //箭头函数中没有this 没有arguments，super(class) ,prototype 
        //不能被new操作符执行
        //箭头函数不能被作为构造函数，更多功能用于计算，数据流向
        //箭头函数具有绑定this 的能力
        //this绑定分为四种
        // 默认绑定(空执行this指向window);隐世绑定(谁调用this指向谁);显示调用(apply，call ，bind);new绑定
        // var name = 'window';
        // var obj = {
        //     name : 'obj',
        //     print : function () {
        //         console.log(this.name);
        //     }
        // }
        
        // obj.print();
        // var newPrint = obj.print.bind(window);
        // var newnewPrint =newPrint.bind(obj);
        // newPrint();//window
        // newnewPrint();//window 绑定失效了

        // var obj1 = {
        //     name : 'obj1',
        //     print : () =>console.log(this.name)
        // }
        // obj1.print();
        // var newPrint = obj1.print.bind(obj1);
        // newPrint();//window 还是绑定不了

        //箭头函数中没有this 具有绑定this能力 函数中绑定this是绑定离自己最近父级的非箭头函数作用域中的this

        // let obj3 = {
        //     name : 'obj3',
        //     getName : function () {
        //         //this =>obj3
        //         let show = () => console.log(this.name);
        //         show();
        //     }
        // }
        // obj3.getName();//this指向obj3

        // function scope () {
        //     setTimeout(() => {
        //         console.log(this.name);
        //     },1000);
        // }
        // scope.call({name:'now you see me'});


        add = () => 1 + 1
    </script>

</body>
</html>